/* vim: ft=cpp
 * ios
 * Copyright © 2010 François-Xavier 'Bombela' Bourlet <bombela@gmail.com>
 *
*/

#pragma once
#ifndef IOS_H
#define IOS_H

#include <kernel/types.h>

namespace kernel {
namespace std {

enum numbase {
	dec       = 0U,
	oct       = 1U,
	hex       = 2U,
	bin       = 3U,
};

enum fmt {
	boolalpha = 1U << 3,
	charalpha = 1U << 4,
	uppercase = 1U << 5,
};

class ios_flags
{
	public:
		constexpr ios_flags(): _flags(_mkflags(dec, charalpha)) {}

		inline void setbase(numbase nb) {
			_flags = (uint8_t(_flags) bitand ~3U) bitor uint8_t(nb); }

		inline void setboolalpha(bool b = true) {
			setbit(fmt::boolalpha, b);
		}
		inline void setcharalpha(bool b = true) {
			setbit(fmt::charalpha, b);
		}
		inline void setuppercase(bool b = true) {
			setbit(fmt::uppercase, b);
		}

		template <typename... Args>
			inline void set(Args... args) {
				_flags = _mkflags(args...);
			}
		inline void reset() { set(dec, charalpha); }

		inline constexpr numbase getbase() const {
			return numbase(uint8_t(_flags) bitand 3U);
		}

		inline constexpr bool isboolalpha() const {
			return uint8_t(_flags) & uint8_t(fmt::boolalpha);
		}

		inline constexpr char ischaralpha() const {
			return uint8_t(_flags) & uint8_t(fmt::charalpha);
		}

		inline constexpr bool isuppercase() const {
			return uint8_t(_flags) & uint8_t(fmt::uppercase);
		}

	private:
		uint8_t _flags;

		inline void setbit(uint8_t bit, bool b) {
			if (b)
				_flags = uint8_t(_flags) bitor uint8_t(bit);
			else
				_flags = uint8_t(_flags) bitand (~uint8_t(bit));
		}

		inline constexpr uint8_t _mkflags() const { return 0; }
		inline constexpr uint8_t _mkflags(numbase nb) const {
			return uint8_t(nb);
		}
		inline constexpr uint8_t _mkflags(fmt f) const { return uint8_t(f); }
		template <typename T, typename... Args>
			inline constexpr uint8_t _mkflags(T a1, Args... args) const {
				return _mkflags(a1) bitor _mkflags(args...);
			}
};

class ios
{
	public:
		ios_flags flags;
};

} // namespace std
} // namespace kernel

#endif /* IOS_H */
