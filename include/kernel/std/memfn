/* vim: ft=cpp
 * memfn
 * Copyright © 2010 François-Xavier 'Bombela' Bourlet <bombela@gmail.com>
 *
*/

#pragma once
#ifndef MEMFN_H
#define MEMFN_H

#include <kernel/std/bits/config.h>
#include <kernel/std/autofun>
#include <kernel/std/forward>

namespace std {
namespace kernel_std {

template <typename F> struct mem_fn_impl;

template <typename R, typename T, typename MPF>
	struct mem_fn_base
	{
		typedef MPF mpf_t;

		constexpr mem_fn_base(mpf_t mpf): mpf(mpf) {}

		template <typename... Args2>
			R operator()(T& obj, Args2&&... args) const {
				return (obj.*mpf)(forward<Args2>(args)...);
			}
		template <typename... Args2>
			R operator()(T* obj, Args2&&... args) const {
				return (obj->*mpf)(forward<Args2>(args)...);
			}

		mpf_t mpf;
	};

template <typename R, typename T, typename... Args>
	struct mem_fn_impl<R (T::*)(Args...)>:
		mem_fn_base<R, T, R (T::*)(Args...)>
	{
		typedef mem_fn_base<R, T, R (T::*)(Args...)> base_t;
		typedef typename base_t::mpf_t mpf_t;

		constexpr mem_fn_impl(mpf_t mpf): base_t(mpf) {}
	};

template <typename R, typename T, typename... Args>
	struct mem_fn_impl<R (T::*)(Args...) const>:
		mem_fn_base<R, const T, R (T::*)(Args...) const>
	{
		typedef mem_fn_base<R, const T, R (T::*)(Args...) const> base_t;
		typedef typename base_t::mpf_t mpf_t;

		constexpr mem_fn_impl(mpf_t mpf): base_t(mpf) {}
	};

template <typename R, typename T, typename... Args>
AUTO_FUN( mem_fn (R (T::*mpf)(Args...)) )
(
	mem_fn_impl<R (T::*)(Args...)>(mpf)
)

template <typename R, typename T, typename... Args>
AUTO_FUN( mem_fn (R (T::*mpf)(Args...) const) )
(
	mem_fn_impl<R (T::*)(Args...) const>(mpf)
)

} // namespace kernel_std
} // namespace std

#endif /* MEMFN_H */
