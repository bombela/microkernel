/* vim: ft=cpp
 * function
 * Copyright © 2011, François-Xavier 'Bombela' Bourlet <bombela@gmail.com>
 *
*/

#pragma once
#ifndef FUNCTION_H
#define FUNCTION_H

#include <kernel/std/bits/config.h>
#include <kernel/std/autofun>
#include <kernel/std/forward>
#include <kernel/std/memfn>
#include <kernel/std/bind>
#include <new>

#include KERNEL_STD_FUNCTION_DEBUG
#include KERNEL_STD_FUNCTION_CHECK

namespace std {
namespace kernel_std {

namespace details {

struct dumb { void f(); };

static const unsigned minsize
	= sizeof (bind(&dumb::f, *(dumb*)0));

} // namespace details

template <typename S, unsigned SIZE = details::minsize>
	struct function;

template <typename R, unsigned SIZE, typename... Args>
	struct function<R (Args...), SIZE>
	{
		typedef R (*PF)(void*, Args...);

		function(): _f(0) {}

		inline operator bool() const { return _f != 0; }

		function(const function& from) = default;

		template <typename F>
			explicit function(F&& f): _f(&holder<F>::call)
			{
				static_assert(SIZE >= sizeof (holder<F>),
						"function to hold too big for the holder! "
						"Use a bigger sized function");
				new (_data) holder<F>(forward<F>(f));
			}
		
		template <typename F>
			function& operator=(F&& f)
			{
				static_assert(SIZE >= sizeof (holder<F>),
						"function to hold too big for the holder! "
						"Use a bigger sized function");
				_f = &holder<F>::call;
				new (_data) holder<F>(forward<F>(f));
				return *this;
			}
		
		auto operator()(Args... args)
		-> decltype(
				(*(PF*)0)(0, (*(Args*)0)...)
				)
		{
			assert(this->_f != 0);
			return this->_f(this->_data, args...);
		}
		
		template <typename F>
			struct holder
			{
				template <typename F2>
					holder(F2&& f): f(forward<F2>(f)) {}

				inline R docall(Args... args)
				{
					return this->f(args...);
				}

				static R call(void* h, Args... args)
				{
					return static_cast<holder*>(h)
						->docall(args...);
				}

				F f;
			};

		PF   _f;
		char _data[SIZE];
	};

} // namespace kernel_std
} // namespace std

#include <check_off.h>
#include <debug_off.h>

#endif /* FUNCTION_H */
