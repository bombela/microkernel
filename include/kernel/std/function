/* vim: ft=cpp
 * function
 * Copyright © 2011, François-Xavier 'Bombela' Bourlet <bombela@gmail.com>
 *
*/

#pragma once
#ifndef FUNCTION_H
#define FUNCTION_H

#include <kernel/std/bits/config.h>
#include <kernel/std/autofun>
#include <kernel/std/forward>
#include <kernel/std/memfn>
#include <kernel/std/bind>

#include KERNEL_STD_FUNCTION_DEBUG
#include KERNEL_STD_FUNCTION_CHECK

namespace std {
namespace kernel_std {

namespace details {

struct dumb { void f(); };

static const unsigned minsize
	= sizeof (bind(&dumb::f, *(dumb*)0));

} // namespace details

template <typename S, unsigned SIZE = details::minsize>
	struct function;

template <typename R, unsigned SIZE, typename... Args>
	struct function<R (Args...), SIZE>
	{
		typedef R (*PF)(void*, Args&&...);

		function(): _f(0) {}

		template <typename F>
			explicit function(F&& f): _f(&holder<F>::call)
			{
				static_assert(SIZE >= sizeof (holder<F>),
						"function to hold too big for the holder! "
						"Use a bigger sized function");
				new (_data) holder<F>(forward<F>(f));
			}
		
		template <typename F>
			function& operator=(F&& f)
			{
				static_assert(SIZE >= sizeof (holder<F>),
						"function to hold too big for the holder! "
						"Use a bigger sized function");
				_f = &holder<F>::call;
				new (_data) holder<F>(forward<F>(f));
				return *this;
			}
		
		template <typename... Args2>
			auto operator()(Args2&&... args)
			-> decltype(
					(*(PF*)0)(0, forward<Args2>((*(Args2*)0))...)
					)
			{
				assert(this->_f != 0);
				return this->_f(this->_data, forward<Args2>(args)...);
			}

		template <typename F>
			struct holder
			{
				template <typename F2>
					holder(F2&& f): f(forward<F2>(f)) {}

				template <typename... Args2>
					inline auto docall(Args2&&... args)
					-> decltype(
								(*(F*)0)(forward<Args2>((*(Args2*)0))...)
							)
					{
						return this->f(forward<Args2>(args)...);
					}

				// gcc-4.6 (GCC) 4.6.0 20110205 (experimental) hack.
				template <typename... Args2>
					struct return_t {
						typedef decltype(
								((holder*)0)
								->docall(forward<Args2>(*(Args2*)0)...)
								) type;
					};

				template <typename... Args2>
					static auto call(void* h, Args2&&... args)
					-> typename return_t<Args2...>::type
					{
						return static_cast<holder*>(h)
							->docall(forward<Args2>(args)...);
					}

				F f;
			};

		PF   _f;
		char _data[SIZE];
	};

} // namespace kernel_std
} // namespace std

#include <check_off.h>
#include <debug_off.h>

#endif /* FUNCTION_H */
